---
sidebar_position: 3
---

# Units

## lib (ПЕРЕДЕЛАТЬ)
Папка lib содержит переиспользуемые методы, функции и логику, которые могут быть использованы в разных частях приложения. В основном, это вспомогательные функции, интеграции с внешними сервисами и общие модели данных. Файлы из папки lib не могут импортировать файлы из папок features, ui и screens, чтобы сохранить независимость и переносимость кода.

Примеры файлов и папок внутри lib:

ads: содержит интеграцию с рекламными платформами, включая контроллеры, хуки, модели и конфигурацию.

AdsController.ts: класс для управления рекламными блоками.
helpers.ts: вспомогательные функции для работы с рекламой.
hooks.ts: хуки для использования рекламных блоков в компонентах.
list.ts: список доступных рекламных блоков.
model.ts: Effector-модели для рекламы.
model.permissions.ts: модели для работы с правами доступа к рекламным блокам.
appInit: содержит логику инициализации приложения, включая кэширование ресурсов и предзагрузку данных.

hook.cachedResources.ts: хук для кэширования и предзагрузки ресурсов приложения.
connection: содержит логику для отслеживания состояния интернет-подключения.

model.internetConnection.ts: Effector-модель для управления состоянием интернет-подключения.
hook.internetConnection.ts: хук для работы с состоянием интернет-подключения.
helpers: содержит общие вспомогательные функции, которые могут быть использованы в разных частях приложения.

array.ts: функции для работы с массивами.
common.ts: общие вспомогательные функции.
date.ts: функции для работы с датами.
strings.ts: функции для работы со строками.
geometry.ts: функции для работы с геометрией и координатами.
objects.ts: функции для работы с объектами.
models: содержит общие модели данных и функции для работы с внешними API.

apiBuilder: набор инструментов для создания и управления API.
ApiDebug.ts: класс для отладки запросов к API.
ApiEndpoints.ts: список конечных точек API.
ApiManager.ts: класс для управления запросами к API.
effect.ts: Effector-эффекты для запросов к API.
Endpoint.ts: класс для представления конечных точек API.
helpers.ts: вспомогательные функции

## ui (ПЕРЕДЕЛАТЬ)
При создании компонентов в папке ui, стоит придерживаться некоторых основных принципов и лучших практик для обеспечения повышенной переиспользуемости, чистоты кода и разделения ответственности.

Простота и функциональность: Компоненты должны быть простыми и выполнять одну конкретную функцию. Это позволяет легче переиспользовать их в разных частях приложения.

Не зависеть от внешнего состояния: Компоненты не должны напрямую зависеть от внешнего состояния, такого как стейт-менеджеры или глобальные переменные. Вместо этого, они должны получать данные через пропсы и использовать коллбеки для взаимодействия с внешним состоянием.

Кастомизация через пропсы: Чтобы обеспечить максимальную гибкость, компоненты должны быть настраиваемыми через пропсы. Это позволяет определять стили, поведение и контент компонента извне.

Разделение стилей и логики: Логика и стили компонентов должны быть разделены. Используйте CSS-модули, стилизованные компоненты или другой подход для изоляции стилей. Это упрощает поддержку и обновление компонентов.

Примеры компонентов ui:

Button
Компонент кнопки, который может быть настроен через пропсы для различных видов и действий.
``` typescript jsx
// ui/buttons/Button.tsx

import React from 'react';
import classNames from 'classnames';
import styles from './Button.module.css';

interface ButtonProps {
  onClick: () => void;
  type?: 'primary' | 'secondary' | 'danger';
  className?: string;
  disabled?: boolean;
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({ onClick, type = 'primary', className, disabled = false, children }) => {
  const buttonClasses = classNames(styles.button, styles[type], className, {
    [styles.disabled]: disabled,
  });

  return (
    <button className={buttonClasses} onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
};

export default Button;

```
Input
Компонент поля ввода, который принимает значение, обработчик изменений и другие параметры через пропсы.
``` typescript jsx
// ui/form/Input.tsx

import React from 'react';
import styles from './Input.module.css';

interface InputProps {
  value: string;
  onChange: (value: string) => void;
  type?: 'text' | 'email' | 'password' | 'number';
  placeholder?: string;
  className?: string;
}

const Input: React.FC<InputProps> = ({ value, onChange, type = 'text', placeholder, className }) => {
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onChange(event.target.value);
  };

  return (
    <input
      className={classNames(styles.input, className)}
      type={type}
      value={value}
      onChange={handleChange}
      placeholder={placeholder}
    />
  );
};

```

### Span для применение шрифтов (описать проблематику)

## screens (ПЕРЕДЕЛАТЬ)
Папка screens содержит компоненты-экраны приложения, которые представляют собой верхний уровень иерархии компонентов и определяют основные разделы приложения. В них объединяются различные компоненты из ui и features, а также управляется состоянием и навигацией между экранами. Важно обеспечить хорошую организацию кода и структуру в папке screens, чтобы облегчить дальнейшее развитие и поддержку приложения.

Вот некоторые лучшие практики для папки screens:

Организация по функциональности: Группируйте экраны в подпапки, основываясь на их функциональности. Это поможет сохранить структуру папки в аккуратном состоянии и сделать код легче для понимания и поддержки.

Выделение контейнеров: Разделяйте логику управления состоянием и представление в компонентах экранов. Для этого используйте контейнеры или высокоуровневые компоненты, которые инкапсулируют логику и передают данные в компоненты-представления через пропсы.

Использование React-хуков: Используйте хуки для управления состоянием, эффектами и другими аспектами логики экрана. Это делает код более декларативным и упрощает повторное использование логики.

Управление навигацией: В зависимости от платформы (React или React Native) и библиотеки навигации, следуйте рекомендациям и лучшим практикам для управления навигацией между экранами.

HomeScreen
Экран домашней страницы приложения, который отображает список элементов и позволяет переходить на экран деталей.
``` typescript jsx

// screens/home/HomeScreen.tsx

import React, { useEffect, useState } from 'react';
import { fetchItems } from '../features/items/api';
import ItemsList from '../features/items/ItemsList';

const HomeScreen: React.FC = () => {
  const [items, setItems] = useState([]);

  useEffect(() => {
    async function fetchData() {
      const data = await fetchItems();
      setItems(data);
    }

    fetchData();
  }, []);

  return <ItemsList items={items} />;
};

export default HomeScreen;
```

## дополнитель (ПЕРЕДЕЛАТЬ)
### api
### constants
### navigation
